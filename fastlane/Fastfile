# Fastfile for Attentive iOS SDK
# This file contains the fastlane lanes for building, testing, and deploying the iOS SDK

FASTLANE_REPORTS_DIR=ENV['FASTLANE_REPORTS_DIR'] || "fastlane/reports"
FASTLANE_TEST_OUTPUT_DIR=ENV['FASTLANE_TEST_OUTPUT_DIR'] || "fastlane/test_output"
FASTLANE_TEST_DEVICE=ENV['FASTLANE_TEST_DEVICE'] || "iPhone 16 Pro"

default_platform(:ios)

platform :ios do
  # ========================
  # Setup and Dependencies
  # ========================
  before_all do
    setup_circle_ci if is_ci
  end

  desc "Setup dependencies and environment"
  lane :setup do
    UI.message("Setting up dependencies...")

    # Resolve Swift Package Manager dependencies
    xcodebuild(
      workspace: "attentive-ios-sdk.xcworkspace",
      scheme: "attentive-ios-sdk-framework",
      xcargs: "-resolvePackageDependencies"
    )

    UI.success("Dependencies resolved successfully")
  end

  # ========================
  # Version Management
  # ========================

  desc "Sync version across all files. Usage: fastlane sync_version version:2.0.11"
  lane :sync_version do |options|
    root_dir = File.expand_path("..", Dir.pwd)
    version_file = File.join(root_dir, ".version")

    # If version provided, update .version file first
    if options[:version]
      File.write(version_file, options[:version])
      UI.message("Updated .version file to: #{options[:version]}")
    end

    # Read version from file
    version = File.read(version_file).strip
    UI.user_error!(".version file is empty") if version.empty?

    UI.message("Syncing version: #{version}")

    # 1. Update ATTNConstants.swift
    constants_file = File.join(root_dir, "Sources/ATTNConstants.swift")
    if File.exist?(constants_file)
      content = File.read(constants_file)
      content.gsub!(/static let sdkVersion = ".*"/, "static let sdkVersion = \"#{version}\"")
      File.write(constants_file, content)
      UI.success("Updated ATTNConstants.swift")
    end

    # 2. Update Package.swift (the URL version)
    package_file = File.join(root_dir, "Package.swift")
    if File.exist?(package_file)
      content = File.read(package_file)
      content.gsub!(%r{releases/download/[0-9.]+[^/]*/}, "releases/download/#{version}/")
      File.write(package_file, content)
      UI.success("Updated Package.swift")
    end

    # 3. Update README.md pod versions
    readme_file = File.join(root_dir, "README.md")
    if File.exist?(readme_file)
      content = File.read(readme_file)
      content.gsub!(/pod 'attentive-ios-sdk', '[^']*'/, "pod 'attentive-ios-sdk', '#{version}'")
      content.gsub!(/pod 'ATTNSDKFramework', '[^']*'/, "pod 'ATTNSDKFramework', '#{version}'")
      File.write(readme_file, content)
      UI.success("Updated README.md")
    end

    UI.success("")
    UI.success("Version sync complete: #{version}")
    UI.message("")
    UI.message("Files updated:")
    UI.message("  - .version (source of truth)")
    UI.message("  - ATTNSDKFramework.podspec (reads from .version)")
    UI.message("  - attentive-ios-sdk.podspec (reads from .version)")
    UI.message("  - Sources/ATTNConstants.swift")
    UI.message("  - Package.swift")
    UI.message("  - README.md")
    UI.message("")
    UI.important("Note: Package.swift checksum must be updated manually after uploading xcframework")

    version
  end

  desc "Get current version from .version file"
  lane :get_version do
    root_dir = File.expand_path("..", Dir.pwd)
    version_file = File.join(root_dir, ".version")
    version = File.read(version_file).strip
    UI.message("Current version: #{version}")
    version
  end

  # ========================
  # iOS Deployment Target Management
  # ========================

  desc "Sync iOS deployment target across all files. Usage: fastlane sync_ios_target target:15.0"
  lane :sync_ios_target do |options|
    root_dir = File.expand_path("..", Dir.pwd)
    target_file = File.join(root_dir, ".ios-deployment-target")

    if options[:target]
      File.write(target_file, options[:target])
      UI.message("Updated .ios-deployment-target file to: #{options[:target]}")
    end

    target = File.read(target_file).strip
    UI.user_error!(".ios-deployment-target file is empty") if target.empty?

    UI.message("Syncing iOS deployment target: #{target}")

    # 1. Update Shared.xcconfig
    xcconfig_file = File.join(root_dir, "Shared.xcconfig")
    if File.exist?(xcconfig_file)
      content = File.read(xcconfig_file)
      content.gsub!(/IPHONEOS_DEPLOYMENT_TARGET = .*/, "IPHONEOS_DEPLOYMENT_TARGET = #{target}")
      File.write(xcconfig_file, content)
      UI.success("Updated Shared.xcconfig")
    end

    # 2. Update Package.swift (platform version)
    package_file = File.join(root_dir, "Package.swift")
    if File.exist?(package_file)
      content = File.read(package_file)
      major_version = target.split('.').first
      content.gsub!(/\.iOS\(\.v\d+\)/, ".iOS(.v#{major_version})")
      File.write(package_file, content)
      UI.success("Updated Package.swift")
    end

    UI.success("")
    UI.success("iOS deployment target sync complete: #{target}")
    UI.message("")
    UI.message("Files updated:")
    UI.message("  - .ios-deployment-target (source of truth)")
    UI.message("  - Shared.xcconfig")
    UI.message("  - Package.swift")
    UI.message("")
    UI.message("Files that read dynamically from .ios-deployment-target:")
    UI.message("  - ATTNSDKFramework.podspec")
    UI.message("  - attentive-ios-sdk.podspec")

    target
  end

  desc "Get current iOS deployment target"
  lane :get_ios_target do
    root_dir = File.expand_path("..", Dir.pwd)
    target_file = File.join(root_dir, ".ios-deployment-target")
    target = File.read(target_file).strip
    UI.message("Current iOS deployment target: #{target}")
    target
  end

  desc "Bump version. Usage: fastlane bump_version type:patch (patch/minor/major)"
  lane :bump_version do |options|
    root_dir = File.expand_path("..", Dir.pwd)
    version_file = File.join(root_dir, ".version")
    current_version = File.read(version_file).strip

    parts = current_version.split('.').map(&:to_i)
    UI.user_error!("Invalid version format: #{current_version}") if parts.length != 3

    bump_type = options[:type] || "patch"

    case bump_type
    when "major"
      parts[0] += 1
      parts[1] = 0
      parts[2] = 0
    when "minor"
      parts[1] += 1
      parts[2] = 0
    when "patch"
      parts[2] += 1
    else
      UI.user_error!("Invalid bump type: #{bump_type}. Use: major, minor, or patch")
    end

    new_version = parts.join('.')
    UI.message("Bumping version: #{current_version} -> #{new_version}")

    sync_version(version: new_version)
  end

  # ========================
  # Code Quality
  # ========================

  desc "Run SwiftLint"
  lane :lint do
    UI.message("Running SwiftLint...")

    # Ensure SwiftLint is installed
    begin
      swiftlint_path = sh("command -v swiftlint", log: false).strip
      UI.message("SwiftLint found at: #{swiftlint_path}")
    rescue => exception
      UI.message("SwiftLint not found, installing via Homebrew...")
      sh("brew install swiftlint")
      UI.success("SwiftLint installed successfully")
    end

    # Create reports directory
    sh("mkdir -p reports")

    # Run SwiftLint
    swiftlint(
      mode: :lint,
      output_file: "#{FASTLANE_REPORTS_DIR}/swiftlint.xml",
      raise_if_swiftlint_error: false,
      reporter: "junit",
      ignore_exit_status: true
    )

    UI.success("SwiftLint passed")
  end

  # ========================
  # Building
  # ========================

  desc "Build framework for device and simulator"
  lane :build_framework do
    project       = "attentive-ios-sdk.xcodeproj"
    scheme        = "attentive-ios-sdk-framework"
    configuration = "Release"
    xcargs        = "CODE_SIGNING_ALLOWED=NO CODE_SIGNING_REQUIRED=NO"

    UI.message("ðŸ—ï¸  Building framework...")

    # Build for iOS Device
    UI.message("Building for iOS Device...")
    xcodebuild(
      project: project,
      scheme: scheme,
      destination: "generic/platform=iOS",
      configuration: configuration,
      clean: true,
      build: true,
      xcargs: xcargs
    )

    # Build for iOS Simulator
    UI.message("Building for iOS Simulator...")
    xcodebuild(
      project: project,
      scheme: scheme,
      destination: "generic/platform=iOS Simulator",
      configuration: configuration,
      clean: true,
      build: true,
      xcargs: xcargs
    )

    UI.success("Framework built successfully")
  end

  desc "Build example apps"
  lane :build_examples do
    destination   = "generic/platform=iOS Simulator"
    configuration = "Debug"
    xcargs        = "CODE_SIGNING_ALLOWED=NO"

    UI.message("Building example apps...")

    # Build Example App (Local)
    UI.message("Building Example - Local...")
    xcodebuild(
      workspace: "attentive-ios-sdk.xcworkspace",
      scheme: "Example - Local",
      destination: destination,
      configuration: configuration,
      clean: true,
      build: true,
      xcargs: xcargs
    )

    # Build Bonni App
    UI.message("Building Bonni...")
    xcodebuild(
      project: "Bonni/Bonni.xcodeproj",
      scheme: "AttentiveExample",
      destination: destination,
      configuration: configuration,
      clean: true,
      build: true,
      xcargs: xcargs
    )

    UI.success("Example apps built successfully")
  end

  lane :build_xcframework do
    project       = "attentive-ios-sdk.xcodeproj"
    scheme        = "attentive-ios-sdk-framework"
    configuration = "Release"
    framework     = "ATTNSDKFramework"
    output_root   = File.expand_path("Build/XCFramework")
    xcargs        = "SKIP_INSTALL=NO, BUILD_LIBRARY_FOR_DISTRIBUTION=YES"

    UI.message "=== Building #{framework} XCFrameworks (scheme: #{scheme}, config: #{configuration}) ==="

    # Build for device
    UI.message "=== [1/3] Build iOS device framework ==="
    build_ios_app(
      project: project,
      scheme: scheme,
      configuration: configuration,
      skip_package_ipa: true,
      skip_archive: true,
      destination: "generic/platform=iOS",
      derived_data_path: "#{output_root}/DerivedData-ios",
      xcargs: xcargs
    )

    ios_framework = "#{output_root}/DerivedData-ios/Build/Products/#{configuration}-iphoneos/#{framework}.framework"
    ios_dsym = "#{output_root}/DerivedData-ios/Build/Products/#{configuration}-iphoneos/#{framework}.framework.dSYM"
    UI.user_error!("iOS device framework not found at #{ios_framework}") unless File.directory?(ios_framework)

    # Strip nested Frameworks directory if present (should not exist with correct build settings)
    nested_frameworks_ios = "#{ios_framework}/Frameworks"
    if File.directory?(nested_frameworks_ios)
      UI.important("Stripping nested Frameworks directory from iOS device framework")
      FileUtils.rm_rf(nested_frameworks_ios)
    end

    # Build for simulator
    UI.message "=== [2/3] Build iOS simulator framework ==="
    build_ios_app(
      project: project,
      scheme: scheme,
      configuration: configuration,
      skip_package_ipa: true,
      skip_archive: true,
      destination: "generic/platform=iOS Simulator",
      derived_data_path: "#{output_root}/DerivedData-sim",
      xcargs: xcargs
    )

    sim_framework = "#{output_root}/DerivedData-sim/Build/Products/#{configuration}-iphonesimulator/#{framework}.framework"
    sim_dsym = "#{output_root}/DerivedData-sim/Build/Products/#{configuration}-iphonesimulator/#{framework}.framework.dSYM"
    UI.user_error!("Simulator framework not found at #{sim_framework}") unless File.directory?(sim_framework)

    # Strip nested Frameworks directory if present (should not exist with correct build settings)
    nested_frameworks_sim = "#{sim_framework}/Frameworks"
    if File.directory?(nested_frameworks_sim)
      UI.important("Stripping nested Frameworks directory from simulator framework")
      FileUtils.rm_rf(nested_frameworks_sim)
    end

    # Create universal framework
    UI.message "=== [3/3] Create universal XCFramework (device + sim) ==="
    universal_xcframework = "#{output_root}/#{framework}.xcframework"

    # Include dSYMs if available
    frameworks_with_dsyms = {}
    if File.directory?(ios_dsym)
      frameworks_with_dsyms[ios_framework] = { dsyms: ios_dsym }
      UI.message "Including iOS device dSYM: #{ios_dsym}"
    else
      frameworks_with_dsyms[ios_framework] = {}
      UI.important "iOS device dSYM not found at #{ios_dsym}, building without it"
    end
    if File.directory?(sim_dsym)
      frameworks_with_dsyms[sim_framework] = { dsyms: sim_dsym }
      UI.message "Including simulator dSYM: #{sim_dsym}"
    else
      frameworks_with_dsyms[sim_framework] = {}
      UI.important "Simulator dSYM not found at #{sim_dsym}, building without it"
    end

    create_xcframework(
      frameworks_with_dsyms: frameworks_with_dsyms,
      output: "#{universal_xcframework}"
    )
    UI.success "Universal XCFramework -> #{universal_xcframework}"

    sh("find #{output_root}/#{framework}.xcframework -name '*.swiftsourceinfo' -delete")
    sh("find #{output_root}/#{framework}.xcframework -type d -name 'Project' -empty -delete")

    UI.success "Done building attentive-ios-sdk XCFrameworks"
  end

  # ========================
  # Testing
  # ========================

  desc "Run unit tests"
  lane :unit_test do
    UI.message("Running unit tests...")
    run_tests(
      project: "attentive-ios-sdk.xcodeproj",
      scheme: "attentive-ios-sdk-framework",
      device: FASTLANE_TEST_DEVICE,
      output_directory: FASTLANE_TEST_OUTPUT_DIR,
      output_types: "html,junit",
      result_bundle: true
    )

    UI.success("Unit tests passed")
  end

  desc "Run UI tests"
  lane :ui_test do
    UI.message("Running UI tests...")

    sh("mkdir -p #{FASTLANE_TEST_OUTPUT_DIR}")

    # Reset simulators for clean state
    UI.message("Resetting simulators...")
    sh("xcrun simctl erase all")

    # Boot simulator
    sh("xcrun simctl boot '#{FASTLANE_TEST_DEVICE}' || true")
    sh("xcrun simctl bootstatus '#{FASTLANE_TEST_DEVICE}'")

    scan(
      workspace: "attentive-ios-sdk.xcworkspace",
      scheme: "CreativeUITest",
      device: FASTLANE_TEST_DEVICE,
      output_directory: FASTLANE_TEST_OUTPUT_DIR,
      output_types: "html,junit",
      result_bundle: true
    )

    UI.success("UI tests passed")
  end

  # ========================
  # Validation
  # ========================

  desc "Validate CocoaPods podspec"
  lane :validate_podspec do
    UI.message("Validating CocoaPods podspec...")

    unless sh("command -v pod", log: false).strip.empty?
      UI.message("CocoaPods already installed")
    else
      UI.message("Installing CocoaPods...")
      sh("sudo gem install cocoapods")
    end

    pod_lib_lint(
      podspec: "ATTNSDKFramework.podspec",
      allow_warnings: true
    )

    UI.success("Podspec validation passed")
  end

  desc "Validate Swift Package Manager"
  lane :validate_spm do
    UI.message("Validating Swift Package...")

    spm(command: "resolve")
    xcodebuild(
      workspace: ".swiftpm/xcode/package.xcworkspace",
      scheme: "ATTNSDKFramework",
      destination: "generic/platform=iOS Simulator",
      build: true
    )

    UI.success("SPM validation passed")
  end

  # ========================
  # Distribution
  # ========================

  desc "Upload a new build to TestFlight"
  lane :beta do
    UI.message("Preparing TestFlight distribution...")

    # Sync code signing
    UI.message("Syncing code signing certificates...")
    sync_code_signing(
      type: "appstore",
      readonly: true
    )

    if ENV["CIRCLE_BUILD_NUM"]
      increment_build_number(
        build_number: ENV["CIRCLE_BUILD_NUM"]
      )
    end

    # Build the app
    UI.message("Building app for App Store...")
    build_ios_app(
      project: "Bonni/Bonni.xcodeproj",
      scheme: "AttentiveExample",
      configuration: "Release",
      export_method: "app-store",
      export_options: {
        provisioningProfiles: {
          ENV["APP_IDENTIFIER"] || "com.attentive.sdk.example" => "match AppStore #{ENV['APP_IDENTIFIER'] || 'com.attentive.sdk.example'}"
        }
      },
      output_directory: "./build",
      clean: true
    )

    # Upload to TestFlight
    UI.message("Uploading to TestFlight...")
    upload_to_testflight
    pilot(
      skip_waiting_for_build_processing: true,
      changelog: "Build #{ENV['CIRCLE_BUILD_NUM'] || 'local'} - #{ENV['CIRCLE_BRANCH'] || 'development'}",
      distribute_external: false,
      notify_external_testers: false
    )

    UI.success("Build uploaded to TestFlight successfully!")
  end

  # ========================
  # Convenience Lanes
  # ========================

  desc "Run all quality checks (lint + test + build)"
  lane :quality do
    UI.message("Running all quality checks...")

    lint
    unit_test
    build_framework

    UI.success("All quality checks passed!")
  end

  desc "Run complete CI validation"
  lane :ci do
    UI.message("Running complete CI validation...")

    setup
    lint
    unit_test
    build_framework
    validate_podspec
    validate_spm
    build_examples

    UI.success("Complete CI validation passed!")
  end

  desc "Run tests only (unit + UI)"
  lane :test_all do
    UI.message("Running all tests...")

    unit_test
    ui_test

    UI.success("All tests passed!")
  end

  # ========================
  # Error Handling
  # ========================

  error do |lane, exception|
    UI.error("Lane #{lane} failed with error:")
    UI.error(exception.message)
  end
end
