# Fastfile for Attentive iOS SDK
# This file contains the fastlane lanes for building, testing, and deploying the iOS SDK

FASTLANE_REPORTS_DIR=ENV['FASTLANE_REPORTS_DIR'] || "fastlane/reports"
FASTLANE_BUILD_OUTPUT_DIR=ENV['FASTLANE_BUILD_OUTPUT_DIR'] || "fastlane/build"
FASTLANE_TEST_OUTPUT_DIR=ENV['FASTLANE_TEST_OUTPUT_DIR'] || "fastlane/test_output"
FASTLANE_TEST_DEVICE=ENV['FASTLANE_TEST_DEVICE'] || "iPhone 17 Pro"

default_platform(:ios)

platform :ios do
  # ========================
  # Setup and Dependencies
  # ========================
  before_all do
    setup_circle_ci if is_ci
  end

  desc "Setup dependencies and environment"
  lane :setup do
    UI.message("üîß Setting up dependencies...")

    # Resolve Swift Package Manager dependencies
    xcodebuild(
      workspace: "attentive-ios-sdk.xcworkspace",
      scheme: "attentive-ios-sdk-framework",
      xcargs: "-resolvePackageDependencies"
    )

    UI.success("‚úÖ Dependencies resolved successfully")
  end

  # ========================
  # Version Management
  # ========================

  desc "Sync version across all files. Usage: fastlane sync_version version:2.0.11"
  lane :sync_version do |options|
    root_dir = File.expand_path("..", Dir.pwd)
    version_file = File.join(root_dir, ".version")

    # If version provided, update .version file first
    if options[:version]
      File.write(version_file, options[:version])
      UI.message("üìù Updated .version file to: #{options[:version]}")
    end

    # Read version from file
    version = File.read(version_file).strip
    UI.user_error!(".version file is empty") if version.empty?

    UI.message("üîÑ Syncing version: #{version}")

    # 1. Update ATTNConstants.swift
    constants_file = File.join(root_dir, "Sources/ATTNConstants.swift")
    if File.exist?(constants_file)
      content = File.read(constants_file)
      content.gsub!(/static let sdkVersion = ".*"/, "static let sdkVersion = \"#{version}\"")
      File.write(constants_file, content)
      UI.success("‚úì Updated ATTNConstants.swift")
    end

    # 2. Update Package.swift (the URL version)
    package_file = File.join(root_dir, "Package.swift")
    if File.exist?(package_file)
      content = File.read(package_file)
      content.gsub!(%r{releases/download/[0-9.]+[^/]*/}, "releases/download/#{version}/")
      File.write(package_file, content)
      UI.success("‚úì Updated Package.swift")
    end

    # 3. Update README.md pod versions
    readme_file = File.join(root_dir, "README.md")
    if File.exist?(readme_file)
      content = File.read(readme_file)
      content.gsub!(/pod 'attentive-ios-sdk', '[^']*'/, "pod 'attentive-ios-sdk', '#{version}'")
      content.gsub!(/pod 'ATTNSDKFramework', '[^']*'/, "pod 'ATTNSDKFramework', '#{version}'")
      File.write(readme_file, content)
      UI.success("‚úì Updated README.md")
    end

    UI.success("")
    UI.success("‚úÖ Version sync complete: #{version}")
    UI.message("")
    UI.message("Files updated:")
    UI.message("  - .version (source of truth)")
    UI.message("  - ATTNSDKFramework.podspec (reads from .version)")
    UI.message("  - attentive-ios-sdk.podspec (reads from .version)")
    UI.message("  - Sources/ATTNConstants.swift")
    UI.message("  - Package.swift")
    UI.message("  - README.md")
    UI.message("")
    UI.important("‚ö†Ô∏è Note: Package.swift checksum must be updated manually after uploading xcframework")

    version
  end

  desc "Get current version from .version file"
  lane :get_version do
    root_dir = File.expand_path("..", Dir.pwd)
    version_file = File.join(root_dir, ".version")
    version = File.read(version_file).strip
    UI.message("Current version: #{version}")
    version
  end

  desc "Bump version. Usage: fastlane bump_version type:patch (patch/minor/major)"
  lane :bump_version do |options|
    root_dir = File.expand_path("..", Dir.pwd)
    version_file = File.join(root_dir, ".version")
    current_version = File.read(version_file).strip

    parts = current_version.split('.').map(&:to_i)
    UI.user_error!("‚ùå Invalid version format: #{current_version}") if parts.length != 3

    bump_type = options[:type] || "patch"

    case bump_type
    when "major"
      parts[0] += 1
      parts[1] = 0
      parts[2] = 0
    when "minor"
      parts[1] += 1
      parts[2] = 0
    when "patch"
      parts[2] += 1
    else
      UI.user_error!("‚ùå Invalid bump type: #{bump_type}. Use: major, minor, or patch")
    end

    new_version = parts.join('.')
    UI.message("üìù Bumping version: #{current_version} ‚Üí #{new_version}")

    sync_version(version: new_version)
  end

  # ========================
  # iOS Deployment Target Management
  # ========================

  desc "Sync iOS deployment target across all files. Usage: fastlane sync_ios_target target:15.0"
  lane :sync_ios_target do |options|
    root_dir = File.expand_path("..", Dir.pwd)
    target_file = File.join(root_dir, ".ios-deployment-target")

    # If target provided, update .ios-deployment-target file first
    if options[:target]
      File.write(target_file, options[:target])
      UI.message("‚úì Updated .ios-deployment-target file to: #{options[:target]}")
    end

    # Read target from file
    target = File.read(target_file).strip
    UI.user_error!(".ios-deployment-target file is empty") if target.empty?

    UI.message("üîÑ Syncing iOS deployment target: #{target}")

    # 1. Update Shared.xcconfig
    xcconfig_file = File.join(root_dir, "Shared.xcconfig")
    if File.exist?(xcconfig_file)
      content = File.read(xcconfig_file)
      content.gsub!(/IPHONEOS_DEPLOYMENT_TARGET = .*/, "IPHONEOS_DEPLOYMENT_TARGET = #{target}")
      File.write(xcconfig_file, content)
      UI.success("‚úì Updated Shared.xcconfig")
    end

    # 2. Update Package.swift (platform version)
    package_file = File.join(root_dir, "Package.swift")
    if File.exist?(package_file)
      content = File.read(package_file)
      # Convert "14.0" to "v14" format for Swift Package Manager
      major_version = target.split('.').first
      content.gsub!(/\.iOS\(\.v\d+\)/, ".iOS(.v#{major_version})")
      File.write(package_file, content)
      UI.success("‚úì Updated Package.swift")
    end

    UI.success("")
    UI.success("‚úÖ iOS deployment target sync complete: #{target}")
    UI.message("")
    UI.message("Files updated:")
    UI.message("  - .ios-deployment-target (source of truth)")
    UI.message("  - Shared.xcconfig")
    UI.message("  - Package.swift")
    UI.message("")
    UI.message("Files that read dynamically from .ios-deployment-target:")
    UI.message("  - ATTNSDKFramework.podspec")
    UI.message("  - attentive-ios-sdk.podspec")

    target
  end

  desc "Get current iOS deployment target"
  lane :get_ios_target do
    root_dir = File.expand_path("..", Dir.pwd)
    target_file = File.join(root_dir, ".ios-deployment-target")
    target = File.read(target_file).strip
    UI.message("Current iOS deployment target: #{target}")
    target
  end

  # ========================
  # Code Quality
  # ========================

  desc "Run SwiftLint"
  lane :lint do
    UI.message("üîç Running SwiftLint...")

    # Ensure SwiftLint is installed
    begin
      swiftlint_path = sh("command -v swiftlint", log: false).strip
      UI.message("‚úÖ SwiftLint found at: #{swiftlint_path}")
    rescue => exception
      UI.message("‚ö†Ô∏è SwiftLint not found, installing via Homebrew...")
      sh("brew install swiftlint")
      UI.success("‚úÖ SwiftLint installed successfully")
    end

    # Create reports directory
    sh("mkdir -p reports")

    # Run SwiftLint
    swiftlint(
      mode: :lint,
      output_file: "#{FASTLANE_REPORTS_DIR}/swiftlint.xml",
      raise_if_swiftlint_error: false,
      reporter: "junit",
      ignore_exit_status: true
    )

    UI.success("‚úÖ SwiftLint passed")
  end

  # ========================
  # Building
  # ========================

  desc "Build framework for device and simulator"
  lane :build_framework do
    project       = "attentive-ios-sdk.xcodeproj"
    scheme        = "attentive-ios-sdk-framework"
    configuration = "Release"
    xcargs        = "CODE_SIGNING_ALLOWED=NO CODE_SIGNING_REQUIRED=NO"

    UI.message("üèóÔ∏è  Building framework...")

    # Build for iOS Device
    UI.message("Building for iOS Device...")
    xcodebuild(
      project: project,
      scheme: scheme,
      destination: "generic/platform=iOS",
      configuration: configuration,
      xcargs: xcargs,
      output_directory: FASTLANE_BUILD_OUTPUT_DIR
    )

    # Build for iOS Simulator
    UI.message("Building for iOS Simulator...")
    xcodebuild(
      project: project,
      scheme: scheme,
      destination: "generic/platform=iOS Simulator",
      configuration: configuration,
      xcargs: xcargs,
      output_directory: FASTLANE_BUILD_OUTPUT_DIR
    )

    UI.success("‚úÖ Framework built successfully")
  end

  desc "Build example apps"
  lane :build_examples do
    destination   = "generic/platform=iOS Simulator"
    configuration = "Debug"
    xcargs        = "CODE_SIGNING_ALLOWED=NO"

    UI.message("üèóÔ∏è Building example apps...")

    # Build Example App (Local)
    UI.message("Building Example - Local...")
    build_ios_app(
      workspace: "attentive-ios-sdk.xcworkspace",
      scheme: "Example - Local",
      configuration: configuration,
      destination: destination,
      skip_package_ipa: true,
      xcargs: xcargs
    )

    # Build Bonni App
    UI.message("Building Bonni...")
    build_ios_app(
      project: "Bonni/Bonni.xcodeproj",
      scheme: "AttentiveExample",
      configuration: configuration,
      destination: destination,
      skip_package_ipa: true,
      xcargs: xcargs
    )

    UI.success("‚úÖ Example apps built successfully")
  end

  desc "Build Bonni for release"
  lane :build_bonni_release do
    # Sync code signing
    UI.message("üîÑ Syncing code signing certificates...")
    sync_code_signing(
      type: "appstore",
      readonly: true
    )

    project_path = "Bonni/Bonni.xcodeproj"
    if ENV["CIRCLE_BUILD_NUM"]
      increment_build_number(
        build_number: ENV["CIRCLE_BUILD_NUM"],
        xcodeproj: project_path
      )
    end

    app_profile_name = ENV["sigh_com.attentive.bonniexample_appstore_profile-name"]
    notification_service_profile_name = ENV["sigh_com.attentive.bonniexample.ATTNNotificationService_appstore_profile-name"]

    # Configure manual signing for each target
    {                                                                                                                
      "AttentiveExample" => app_profile_name,
      "ATTNNotificationService" => notification_service_profile_name
    }.each do |target, profile|
      update_code_signing_settings(
        use_automatic_signing: false,
        path: project_path,
        targets: [target],
        profile_name: profile,
        code_sign_identity: "Apple Distribution"
        )
    end

    # Build the app
    UI.message("üèóÔ∏è Building app for App Store...")
    build_ios_app(
      project: project_path,
      scheme: "AttentiveExample",
      configuration: "Release",
      export_method: "app-store",
      export_options: {
        provisioningProfiles: {
          "com.attentive.bonniexample" => app_profile_name,
          "com.attentive.bonniexample.ATTNNotificationService" => notification_service_profile_name
        }
      },
      output_directory: FASTLANE_BUILD_OUTPUT_DIR,
      clean: true
    )
  end

  desc "Build XCFramework"
  lane :build_xcframework do
    project       = "attentive-ios-sdk.xcodeproj"
    scheme        = "attentive-ios-sdk-framework"
    configuration = "Release"
    framework     = "ATTNSDKFramework"
    output_root   = File.expand_path("Build/XCFramework")
    xcargs        = "SKIP_INSTALL=NO BUILD_LIBRARY_FOR_DISTRIBUTION=YES"

    UI.message("üèóÔ∏è Building #{framework} XCFrameworks (scheme: #{scheme}, config: #{configuration})")

    # Build for device
    UI.message("[1/3] Build iOS device framework")
    xcodebuild(
      project: project,
      scheme: scheme,
      configuration: configuration,
      build: true,
      destination: "generic/platform=iOS",
      derivedDataPath: "#{output_root}/DerivedData-ios",
      xcargs: xcargs
    )

    ios_framework = "#{output_root}/DerivedData-ios/Build/Products/#{configuration}-iphoneos/#{framework}.framework"
    ios_dsym = "#{output_root}/DerivedData-ios/Build/Products/#{configuration}-iphoneos/#{framework}.framework.dSYM"
    UI.user_error!("iOS device framework not found at #{ios_framework}") unless File.directory?(ios_framework)

    # Strip nested Frameworks directory if present (should not exist with correct build settings)
    nested_frameworks_ios = "#{ios_framework}/Frameworks"
    if File.directory?(nested_frameworks_ios)
      UI.important("Stripping nested Frameworks directory from iOS device framework")
      FileUtils.rm_rf(nested_frameworks_ios)
    end

    # Build for simulator
    UI.message("[2/3] Build iOS simulator framework")
    xcodebuild(
      project: project,
      scheme: scheme,
      configuration: configuration,
      build: true,
      destination: "generic/platform=iOS Simulator",
      derivedDataPath: "#{output_root}/DerivedData-sim",
      xcargs: xcargs
    )

    sim_framework = "#{output_root}/DerivedData-sim/Build/Products/#{configuration}-iphonesimulator/#{framework}.framework"
    sim_dsym = "#{output_root}/DerivedData-sim/Build/Products/#{configuration}-iphonesimulator/#{framework}.framework.dSYM"
    UI.user_error!("Simulator framework not found at #{sim_framework}") unless File.directory?(sim_framework)

    # Strip nested Frameworks directory if present (should not exist with correct build settings)
    nested_frameworks_sim = "#{sim_framework}/Frameworks"
    if File.directory?(nested_frameworks_sim)
      UI.important("Stripping nested Frameworks directory from simulator framework")
      FileUtils.rm_rf(nested_frameworks_sim)
    end

    # Create universal framework
    UI.message("[3/3] Create universal XCFramework (device + sim)")
    universal_xcframework = "#{output_root}/#{framework}.xcframework"

    # Include dSYMs if available
    frameworks_with_dsyms = {}
    if File.directory?(ios_dsym)
      frameworks_with_dsyms[ios_framework] = { dsyms: ios_dsym }
      UI.message("Including iOS device dSYM: #{ios_dsym}")
    else
      frameworks_with_dsyms[ios_framework] = {}
      UI.important("iOS device dSYM not found at #{ios_dsym}, building without it")
    end
    if File.directory?(sim_dsym)
      frameworks_with_dsyms[sim_framework] = { dsyms: sim_dsym }
      UI.message("Including simulator dSYM: #{sim_dsym}")
    else
      frameworks_with_dsyms[sim_framework] = {}
      UI.important("Simulator dSYM not found at #{sim_dsym}, building without it")
    end

    create_xcframework(
      frameworks_with_dsyms: frameworks_with_dsyms,
      output: "#{universal_xcframework}"
    )
    UI.success("Universal XCFramework ‚Üí #{universal_xcframework}")

    sh("find #{output_root}/#{framework}.xcframework -name '*.swiftsourceinfo' -delete")
    sh("find #{output_root}/#{framework}.xcframework -type d -name 'Project' -empty -delete")

    UI.success("‚úÖ Done building #{framework}")
  end

  # ========================
  # Testing
  # ========================

  desc "Run unit tests"
  lane :unit_test do
    UI.message("üß™ Running unit tests...")
    run_tests(
      project: "attentive-ios-sdk.xcodeproj",
      scheme: "attentive-ios-sdk-framework",
      device: FASTLANE_TEST_DEVICE,
      output_directory: FASTLANE_TEST_OUTPUT_DIR,
      output_types: "html,junit",
      result_bundle: true
    )

    UI.success("‚úÖ Unit tests passed")
  end

  # ========================
  # Validation
  # ========================

  desc "Validate CocoaPods podspec"
  lane :validate_podspec do
    UI.message("üîé Validating CocoaPods podspec...")

    begin
      sh("command -v pod", log: false)
      UI.message("CocoaPods already installed")
    rescue
      UI.message("Installing CocoaPods...")
      sh("sudo gem install cocoapods")
    end

    pod_lib_lint(
      podspec: "ATTNSDKFramework.podspec",
      allow_warnings: true
    )

    UI.success("‚úÖ Podspec validation passed")
  end

  desc "Validate Swift Package Manager"
  lane :validate_spm do
    UI.message("üîé Validating Swift Package...")

    spm(command: "resolve")
    xcodebuild(
      workspace: ".swiftpm/xcode/package.xcworkspace",
      scheme: "ATTNSDKFramework",
      destination: "generic/platform=iOS Simulator",
      build: true
    )

    UI.success("‚úÖ SPM validation passed")
  end

  # ========================
  # Distribution
  # ========================

  desc "Upload a new build to TestFlight"
  lane :deploy_testflight do
    UI.message("üîß Preparing TestFlight distribution...")

    api_key = app_store_connect_api_key(
      key_id: ENV["APP_STORE_CONNECT_API_KEY_ID"],
      issuer_id: ENV["APP_STORE_CONNECT_ISSUER_ID"],
      key_content: ENV["APP_STORE_CONNECT_API_KEY_CONTENT"],
      is_key_content_base64: true
    )

    # Upload to TestFlight
    UI.message("üöÄ Uploading to TestFlight...")
    upload_to_testflight(
      api_key: api_key,
      ipa: FASTLANE_BUILD_OUTPUT_DIR
    )
    UI.success("‚úÖ Build uploaded to TestFlight successfully!")
  end

  # ========================
  # Error Handling
  # ========================

  error do |lane, exception|
    UI.error("‚ùå Lane #{lane} failed with error:")
    UI.error(exception.message)
  end
end
